<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›ì¹´ë“œ í”„ë¡œ (ì¡°ì»¤ ë£° ìˆ˜ì •íŒ)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2e7d32;
            color: white;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* í­ì£½ ìº”ë²„ìŠ¤ */
        #confetti-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10000;
        }

        #game-board {
            flex: 1;
            position: relative;
            display: grid;
            grid-template-rows: 1fr 2fr 1fr;
            grid-template-columns: 1fr 2fr 1fr;
            padding: 10px;
        }

        .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            position: relative;
            padding: 5px;
            transition: opacity 0.3s;
        }

        .active-turn {
            background-color: rgba(255, 255, 0, 0.15);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
        }

        /* ê·¸ë¦¬ë“œ ë°°ì¹˜ */
        #cpu2 { grid-area: 1 / 2 / 2 / 3; }
        #cpu1 { grid-area: 2 / 1 / 3 / 2; }
        #cpu3 { grid-area: 2 / 3 / 3 / 4; }
        #player { grid-area: 3 / 2 / 4 / 3; }
        
        #center-area {
            grid-area: 2 / 2 / 3 / 3;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        #cards-zone {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        /* í˜„ì¬ ë¬´ëŠ¬ í‘œì‹œê¸° */
        #current-suit-indicator {
            font-size: 18px;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 5px 15px;
            border-radius: 20px;
            color: #fff;
            min-height: 27px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .suit-icon { font-size: 24px; }
        .red-suit { color: #ff5252; }
        .black-suit { color: #fff; }
        .any-suit { color: #ffeb3b; text-shadow: 0 0 5px orange; }

        /* í”Œë ˆì´ì–´ ì´ë¦„í‘œ */
        .player-name {
            background: rgba(0,0,0,0.5);
            padding: 2px 10px;
            border-radius: 10px;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        /* ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .card {
            width: 60px; height: 90px;
            background-color: white;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            font-weight: bold;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        }
        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }
        .card.joker-black { color: black; border: 2px solid #555; }
        .card.joker-color { color: red; border: 2px solid #ff9800; }

        .card-back {
            background-color: #1a237e;
            background-image: repeating-linear-gradient(45deg, #1a237e 0, #1a237e 5px, #283593 5px, #283593 10px);
            border: 2px solid #fff;
            color: transparent;
        }

        /* CPU ì†íŒ¨ ì‹œê°í™” */
        .cpu-hand-visual {
            display: flex; justify-content: center; align-items: center; height: 100px;
        }
        .cpu-card {
            width: 40px; height: 60px;
            border-radius: 4px;
            box-shadow: -1px 0 3px rgba(0,0,0,0.3);
            margin-left: -25px;
            transition: all 0.3s ease;
        }
        .cpu-card:first-child { margin-left: 0; }
        
        #cpu1 .cpu-hand-visual, #cpu3 .cpu-hand-visual {
            flex-direction: column; width: 100px; height: auto;
        }
        #cpu1 .cpu-card, #cpu3 .cpu-card {
            margin-left: 0; margin-top: -45px; transform: rotate(90deg);
        }
        #cpu1 .cpu-card:first-child, #cpu3 .cpu-card:first-child { margin-top: 0; }

        /* í”Œë ˆì´ì–´ ì†íŒ¨ */
        #player-hand { display: flex; gap: -5px; margin-top: 5px; }
        #player-hand .card { margin: 0 3px; }
        #player-hand .card:hover { transform: translateY(-15px) scale(1.1); z-index: 10; }

        /* ì›ì¹´ë“œ ë²„íŠ¼ */
        #one-card-btn {
            position: absolute;
            width: 100px; height: 100px;
            background: radial-gradient(circle, #ffeb3b 0%, #fbc02d 100%);
            color: #d32f2f; font-size: 20px; font-weight: 900;
            border: 5px solid #d32f2f; border-radius: 50%;
            cursor: pointer; z-index: 9999; display: none;
            box-shadow: 0 0 30px #ffeb3b;
            animation: pulse 0.5s infinite;
            text-align: center; line-height: 90px;
        }
        #one-card-btn:active { transform: scale(0.9); }
        @keyframes pulse { 0% {transform:scale(1);} 50% {transform:scale(1.1);} 100% {transform:scale(1);} }

        /* ë¡œê·¸ì°½ */
        #game-log {
            position: absolute; bottom: 10px; left: 10px;
            width: 220px; height: 150px;
            background: rgba(0,0,0,0.6); color: #ddd;
            overflow-y: auto; font-size: 11px; padding: 8px;
            border-radius: 5px; pointer-events: none;
        }
        #game-log::-webkit-scrollbar { display: none; }

        /* ë‹¤ì‹œí•˜ê¸° ë²„íŠ¼ */
        #restart-btn {
            position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background-color: #0288d1;
            color: white; border: none; border-radius: 5px;
            font-size: 16px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: none; z-index: 10001;
        }
        #restart-btn:hover { background-color: #03a9f4; }

        /* ë¬´ëŠ¬ ì„ íƒ ëª¨ë‹¬ (7ìš©) */
        #suit-modal {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none; justify-content: center; align-items: center;
            z-index: 20000; flex-direction: column;
        }
        .suit-options { display: flex; gap: 20px; margin-top: 20px; }
        .suit-btn {
            width: 80px; height: 80px;
            font-size: 40px; background: white;
            border: none; border-radius: 10px; cursor: pointer;
        }
        .suit-btn:hover { transform: scale(1.1); background: #eee; }
        
        #deck { cursor: pointer; transition: transform 0.1s; }
        #deck:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <canvas id="confetti-canvas"></canvas>
    <button id="restart-btn" onclick="location.reload()">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>

    <!-- ë¬´ëŠ¬ ì„ íƒ íŒì—… -->
    <div id="suit-modal">
        <h2 style="color:white;">ë³€ê²½í•  ë¬´ëŠ¬ë¥¼ ì„ íƒí•˜ì„¸ìš”!</h2>
        <div class="suit-options">
            <button class="suit-btn" onclick="resolveSuitSelection('â™ ')" style="color:black">â™ </button>
            <button class="suit-btn" onclick="resolveSuitSelection('â™¦')" style="color:red">â™¦</button>
            <button class="suit-btn" onclick="resolveSuitSelection('â™¥')" style="color:red">â™¥</button>
            <button class="suit-btn" onclick="resolveSuitSelection('â™£')" style="color:black">â™£</button>
        </div>
    </div>

    <div id="game-board">
        <!-- CPU 2 (Top) -->
        <div id="cpu2" class="player-area">
            <div class="player-name">CPU 2</div>
            <div class="cpu-hand-visual"></div>
        </div>

        <!-- CPU 1 (Left) -->
        <div id="cpu1" class="player-area">
            <div class="player-name">CPU 1</div>
            <div class="cpu-hand-visual"></div>
        </div>

        <!-- Center -->
        <div id="center-area">
            <div id="current-suit-indicator"></div>
            <div id="cards-zone">
                <div id="deck" class="card card-back" onclick="playerDraw()">Deck</div>
                <div id="discard-pile" class="card"></div>
            </div>
        </div>

        <!-- CPU 3 (Right) -->
        <div id="cpu3" class="player-area">
            <div class="player-name">CPU 3</div>
            <div class="cpu-hand-visual"></div>
        </div>

        <!-- Player -->
        <div id="player" class="player-area">
            <div class="player-name">YOU</div>
            <div id="player-hand"></div>
        </div>
    </div>

    <div id="one-card-btn">ì›ì¹´ë“œ!</div>
    <div id="game-log"></div>

<script>
    /* ==============================
       ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ
       ============================== */
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'play') {
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'draw') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(400, now + 0.15);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.linearRampToValueAtTime(0.01, now + 0.15);
            osc.start(now); osc.stop(now + 0.15);
        } else if (type === 'alert') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.setValueAtTime(800, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'special') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

    function playFanfare() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const notes = [523.25, 659.25, 783.99, 1046.50];
        let time = audioCtx.currentTime;
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            osc.type = 'triangle'; osc.frequency.value = freq;
            const duration = (i === notes.length - 1) ? 0.8 : 0.2;
            gainNode.gain.setValueAtTime(0.3, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + duration);
            osc.start(time); osc.stop(time + duration);
            time += 0.15;
        });
    }

    /* ==============================
       í­ì£½ (Confetti)
       ============================== */
    const canvas = document.getElementById('confetti-canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationId = null;

    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function createConfetti() {
        for (let i = 0; i < 150; i++) {
            particles.push({
                x: window.innerWidth / 2, y: window.innerHeight / 2,
                vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15 - 5,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                size: Math.random() * 8 + 4, gravity: 0.2, drag: 0.96
            });
        }
        animateConfetti();
    }

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.vx *= p.drag; p.vy *= p.drag;
            ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
            if (p.y > canvas.height) particles.splice(i, 1);
        });
        if (particles.length > 0) animationId = requestAnimationFrame(animateConfetti);
        else cancelAnimationFrame(animationId);
    }

    /* ==============================
       ê²Œì„ ë¡œì§
       ============================== */
    const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    let deck = [];
    let discardPile = [];
    let players = [
        { id: 0, name: "YOU", isCpu: false, hand: [] },
        { id: 1, name: "CPU 1", isCpu: true, hand: [] },
        { id: 2, name: "CPU 2", isCpu: true, hand: [] },
        { id: 3, name: "CPU 3", isCpu: true, hand: [] }
    ];
    
    let currentPlayerIndex = 0;
    let turnDirection = 1;
    let isGameRunning = true;
    let oneCardTimer = null;
    let isProcessingTurn = false;
    let currentEffectiveSuit = null; // 'ANY' ë˜ëŠ” ë¬¸ì–‘

    // DOM
    const discardEl = document.getElementById('discard-pile');
    const playerHandEl = document.getElementById('player-hand');
    const oneCardBtn = document.getElementById('one-card-btn');
    const logEl = document.getElementById('game-log');
    const suitIndicator = document.getElementById('current-suit-indicator');
    const suitModal = document.getElementById('suit-modal');
    const restartBtn = document.getElementById('restart-btn');
    const cpuVisuals = [null, document.querySelector('#cpu1 .cpu-hand-visual'), document.querySelector('#cpu2 .cpu-hand-visual'), document.querySelector('#cpu3 .cpu-hand-visual')];

    function initGame() {
        createDeck();
        shuffleDeck();
        dealCards();
        updateUI();
        log("ê²Œì„ ì‹œì‘! í–‰ìš´ì„ ë¹•ë‹ˆë‹¤.");
        highlightCurrentPlayer();
    }

    function createDeck() {
        deck = [];
        for (let suit of suits) {
            for (let rank of ranks) {
                deck.push({ suit, rank, isJoker: false });
            }
        }
        // ì¡°ì»¤ ì¶”ê°€
        deck.push({ suit: 'Joker', rank: 'Black', isJoker: true });
        deck.push({ suit: 'Joker', rank: 'Color', isJoker: true });
    }

    function shuffleDeck() {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }

    function dealCards() {
        for (let i = 0; i < 5; i++) {
            players.forEach(p => { if(deck.length > 0) p.hand.push(deck.pop()); });
        }
        // ì‹œì‘ ì¹´ë“œ ì²˜ë¦¬
        let firstCard = deck.pop();
        discardPile.push(firstCard);
        
        // í”¼ë“œë°± ë°˜ì˜: ì‹œì‘ ì¹´ë“œê°€ ì¡°ì»¤ë©´ 'ANY' ìƒíƒœ, ì•„ë‹ˆë©´ í•´ë‹¹ ë¬¸ì–‘
        if (firstCard.isJoker) {
            currentEffectiveSuit = 'ANY';
            log("ì²« ì¹´ë“œê°€ ì¡°ì»¤! ì•„ë¬´ê±°ë‚˜ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        } else {
            currentEffectiveSuit = firstCard.suit;
        }
    }

    function drawCardFromDeck(player) {
        if (deck.length === 0) reshuffleDiscardPile();
        if (deck.length > 0) {
            player.hand.push(deck.pop());
            playSound('draw');
        }
    }

    function reshuffleDiscardPile() {
        if (discardPile.length <= 1) return;
        const topCard = discardPile.pop();
        const newDeck = discardPile;
        discardPile = [topCard];
        deck = newDeck;
        shuffleDeck();
        log("ë± ë¦¬í•„ë¨");
    }

    // ----- íŒì • ë¡œì§ (ìˆ˜ì •ë¨) -----
    function isValidMove(card, topCard) {
        // ë‚´ë ¤ëŠ” ì¹´ë“œê°€ ì¡°ì»¤ë©´ ë¬´ì¡°ê±´ ê°€ëŠ¥
        if (card.isJoker) return true;

        // ë°”ë‹¥ì´ ì¡°ì»¤ê±°ë‚˜ 'ANY' ìƒíƒœë©´ ì•„ë¬´ê±°ë‚˜ ê°€ëŠ¥ (í”¼ë“œë°± ë°˜ì˜)
        if (topCard.isJoker || currentEffectiveSuit === 'ANY') {
            return true;
        }
        
        // ì¼ë°˜ì ì¸ ê²½ìš°: ìˆ«ìê°€ ê°™ê±°ë‚˜, ì§€ì •ëœ ë¬´ëŠ¬ì™€ ê°™ì•„ì•¼ í•¨
        return card.rank === topCard.rank || card.suit === currentEffectiveSuit;
    }

    // ----- ì›ì¹´ë“œ ë²„íŠ¼ ë¡œì§ -----
    function checkOneCardEvent(playerIndex, callback) {
        const player = players[playerIndex];
        if (player.hand.length === 1) {
            spawnOneCardButton(playerIndex, callback);
        } else {
            callback();
        }
    }

    function spawnOneCardButton(targetPlayerIndex, callback) {
        playSound('alert');
        const size = 100;
        const maxX = window.innerWidth - size - 20;
        const maxY = window.innerHeight - size - 20;
        
        oneCardBtn.style.left = Math.max(10, Math.random() * maxX) + 'px';
        oneCardBtn.style.top = Math.max(10, Math.random() * maxY) + 'px';
        oneCardBtn.style.display = 'block';

        let clicked = false;
        
        oneCardBtn.onclick = () => {
            clicked = true;
            oneCardBtn.style.display = 'none';
            clearTimeout(oneCardTimer);

            if (targetPlayerIndex === 0) {
                log("ë‚˜: ë°©ì–´ ì„±ê³µ!");
            } else {
                log(`${players[targetPlayerIndex].name} ê²¬ì œ ì„±ê³µ! (+1ì¥)`);
                drawCardFromDeck(players[targetPlayerIndex]);
                updateUI();
            }
            callback();
        };

        oneCardTimer = setTimeout(() => {
            oneCardBtn.onclick = null;
            if (!clicked) {
                oneCardBtn.style.display = 'none';
                if (targetPlayerIndex === 0) {
                    log("ë°©ì–´ ì‹¤íŒ¨... (+1ì¥)");
                    drawCardFromDeck(players[0]);
                } else {
                    log(`${players[targetPlayerIndex].name}: "ì›ì¹´ë“œ!"`);
                }
                updateUI();
                callback();
            }
        }, 900);
    }

    // ----- í„´ ë° íŠ¹ìˆ˜ íš¨ê³¼ ë¡œì§ -----
    function processCardEffect(card, playerIndex) {
        const player = players[playerIndex];

        // 1. K (King): í•œ ë²ˆ ë”
        if (card.rank === 'K') {
            log(`${player.name}: King! í•œ ë²ˆ ë”!`);
            playSound('special');
            return "REPEAT"; 
        }

        // 2. Q (Queen): ìˆœì„œ ë°˜ì „
        if (card.rank === 'Q') {
            log(`${player.name}: Queen! ìˆœì„œ ë°˜ì „!`);
            playSound('special');
            turnDirection *= -1;
        }

        // 3. J (Jump): ì í”„
        if (card.rank === 'J') {
            log(`${player.name}: Jump! ë‹¤ìŒ ì‚¬ëŒ ê±´ë„ˆë›°ê¸°`);
            playSound('special');
            currentPlayerIndex = (currentPlayerIndex + turnDirection + 4) % 4;
        }

        // 4. 7 (Seven): ë¬´ëŠ¬ ë³€ê²½ (ì¡°ì»¤ ì œì™¸)
        if (card.rank === '7') {
            playSound('special');
            if (player.isCpu) {
                const counts = {'â™ ':0, 'â™¥':0, 'â™¦':0, 'â™£':0};
                player.hand.forEach(c => { if(!c.isJoker) counts[c.suit]++; });
                const bestSuit = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                currentEffectiveSuit = bestSuit;
                log(`${player.name}ê°€ ë¬´ëŠ¬ë¥¼ ${bestSuit}(ìœ¼)ë¡œ ë³€ê²½!`);
                return "NEXT";
            } else {
                openSuitModal();
                return "WAIT_UI";
            }
        }

        return "NEXT";
    }

    function resolveSuitSelection(selectedSuit) {
        suitModal.style.display = 'none';
        currentEffectiveSuit = selectedSuit;
        log(`ë¬´ëŠ¬ë¥¼ ${selectedSuit}(ìœ¼)ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
        updateUI();
        
        nextTurn();
    }

    function openSuitModal() {
        suitModal.style.display = 'flex';
    }

    function nextTurn() {
        if (!isGameRunning) return;

        if (checkWinCondition(currentPlayerIndex)) return;

        currentPlayerIndex = (currentPlayerIndex + turnDirection + 4) % 4;
        
        updateUI();
        highlightCurrentPlayer();

        if (players[currentPlayerIndex].isCpu) {
            isProcessingTurn = true;
            setTimeout(cpuPlay, 1000);
        } else {
            isProcessingTurn = false;
            log("ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.");
        }
    }

    function checkWinCondition(playerIndex) {
        if (players[playerIndex].hand.length === 0) {
            isGameRunning = false;
            const pName = players[playerIndex].name;
            restartBtn.style.display = 'block';

            if (playerIndex === 0) {
                playFanfare();
                createConfetti();
                log(`ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ${pName} ìŠ¹ë¦¬!`);
            } else {
                log(`${pName} ìŠ¹ë¦¬... ë‹¤ìŒ ê¸°íšŒì—!`);
            }
            return true;
        }
        return false;
    }

    // ----- í”Œë ˆì´ì–´ ì•¡ì…˜ -----
    function playerPlayCard(cardIndex) {
        if (currentPlayerIndex !== 0 || isProcessingTurn) return;

        const card = players[0].hand[cardIndex];
        const topCard = discardPile[discardPile.length - 1];

        if (isValidMove(card, topCard)) {
            isProcessingTurn = true;
            
            players[0].hand.splice(cardIndex, 1);
            discardPile.push(card);
            
            // ë¬´ëŠ¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            if (card.isJoker) {
                currentEffectiveSuit = 'ANY'; // ì¡°ì»¤ ë‚´ë©´ ë‹¤ìŒì€ ì•„ë¬´ê±°ë‚˜
            } else if (card.rank !== '7') {
                currentEffectiveSuit = card.suit; // 7 ì œì™¸ ì¼ë°˜ ì¹´ë“œëŠ” í•´ë‹¹ ë¬´ëŠ¬ë¡œ ê³ ì •
            }
            // 7ì€ processCardEffectì—ì„œ ì²˜ë¦¬
            
            playSound('play');
            updateUI();

            if (players[0].hand.length === 0) {
                checkWinCondition(0);
                return;
            }

            checkOneCardEvent(0, () => {
                const effectResult = processCardEffect(card, 0);
                
                if (effectResult === "WAIT_UI") {
                    // ëŒ€ê¸°
                } else if (effectResult === "REPEAT") {
                    isProcessingTurn = false; 
                    log("í•œ ë²ˆ ë” ë‚´ì„¸ìš”!");
                    updateUI();
                } else {
                    nextTurn();
                }
            });

        } else {
            log("ë‚¼ ìˆ˜ ì—†ëŠ” ì¹´ë“œì…ë‹ˆë‹¤.");
        }
    }

    function playerDraw() {
        if (currentPlayerIndex !== 0 || isProcessingTurn) return;
        drawCardFromDeck(players[0]);
        updateUI();
        nextTurn();
    }

    // ----- CPU ë¡œì§ -----
    function cpuPlay() {
        if (!isGameRunning) return;

        const cpu = players[currentPlayerIndex];
        const topCard = discardPile[discardPile.length - 1];
        
        const validIndex = cpu.hand.findIndex(c => isValidMove(c, topCard));

        if (validIndex !== -1) {
            const card = cpu.hand.splice(validIndex, 1)[0];
            discardPile.push(card);

            // ë¬´ëŠ¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            if (card.isJoker) {
                currentEffectiveSuit = 'ANY';
            } else if (card.rank !== '7') {
                currentEffectiveSuit = card.suit;
            }

            playSound('play');
            updateUI();
            
            let cardName = card.isJoker ? `JOKER(${card.rank})` : `${card.suit}${card.rank}`;
            log(`${cpu.name} > ${cardName}`);

            if (cpu.hand.length === 0) {
                checkWinCondition(currentPlayerIndex);
                return;
            }

            checkOneCardEvent(currentPlayerIndex, () => {
                const effectResult = processCardEffect(card, currentPlayerIndex);

                if (effectResult === "REPEAT") {
                    setTimeout(cpuPlay, 1000);
                } else {
                    nextTurn();
                }
            });

        } else {
            drawCardFromDeck(cpu);
            log(`${cpu.name} ë“œë¡œìš°`);
            updateUI();
            nextTurn();
        }
    }

    // ----- UI ì—…ë°ì´íŠ¸ -----
    function updateUI() {
        const top = discardPile[discardPile.length - 1];
        let displayText = top.isJoker ? (top.rank === 'Black' ? 'ğŸ¤¡' : 'ğŸ‘¹') : `${top.suit}${top.rank}`;
        let cssClass = `card ${['â™¥','â™¦'].includes(top.suit) || top.rank === 'Color' ? 'red' : 'black'}`;
        
        if (top.isJoker) {
            cssClass = top.rank === 'Color' ? 'card joker-color' : 'card joker-black';
            displayText = "JOKER";
        }

        discardEl.className = cssClass;
        discardEl.textContent = displayText;

        // ë¬´ëŠ¬ í‘œì‹œ ì—…ë°ì´íŠ¸
        if (currentEffectiveSuit === 'ANY') {
            suitIndicator.innerHTML = `í˜„ì¬: <span class="suit-icon any-suit">ììœ  (ì•„ë¬´ê±°ë‚˜)</span>`;
        } else {
            let suitColor = ['â™¥','â™¦'].includes(currentEffectiveSuit) ? 'red-suit' : 'black-suit';
            suitIndicator.innerHTML = `í˜„ì¬ ë¬´ëŠ¬: <span class="suit-icon ${suitColor}">${currentEffectiveSuit}</span>`;
        }

        // ë‚´ íŒ¨
        playerHandEl.innerHTML = '';
        players[0].hand.forEach((card, index) => {
            const d = document.createElement('div');
            let cClass = `card ${['â™¥','â™¦'].includes(card.suit) ? 'red' : 'black'}`;
            let cText = `${card.suit}${card.rank}`;
            
            if (card.isJoker) {
                cClass = card.rank === 'Color' ? 'card joker-color' : 'card joker-black';
                cText = "JK";
            }

            d.className = cClass;
            d.textContent = cText;
            d.onclick = () => playerPlayCard(index);
            playerHandEl.appendChild(d);
        });

        // CPU íŒ¨
        for(let i=1; i<=3; i++) {
            const visualContainer = cpuVisuals[i];
            visualContainer.innerHTML = '';
            const count = players[i].hand.length;
            for(let k=0; k<count; k++) {
                const cardBack = document.createElement('div');
                cardBack.className = 'card card-back cpu-card';
                visualContainer.appendChild(cardBack);
            }
        }
    }

    function highlightCurrentPlayer() {
        document.querySelectorAll('.player-area').forEach(el => el.classList.remove('active-turn'));
        const ids = ['player', 'cpu1', 'cpu2', 'cpu3'];
        document.getElementById(ids[currentPlayerIndex]).classList.add('active-turn');
    }

    function log(msg) {
        const p = document.createElement('div');
        p.textContent = msg;
        logEl.appendChild(p);
        logEl.scrollTop = logEl.scrollHeight;
    }

    window.onload = initGame;
</script>
</body>
</html>