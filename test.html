<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏõêÏπ¥Îìú ÌîÑÎ°ú (Î∞∞ÏßÄ Î≤ÑÍ∑∏ ÏàòÏ†ïÌåê)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2e7d32;
            color: white;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #confetti-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10000;
        }

        #game-board {
            flex: 1;
            position: relative;
            display: grid;
            grid-template-rows: 1fr 2fr 1fr;
            grid-template-columns: 1fr 2fr 1fr;
            padding: 10px;
        }

        .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            position: relative;
            padding: 5px;
            transition: opacity 0.3s;
        }

        .active-turn {
            background-color: rgba(255, 255, 0, 0.15);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
        }

        #cpu2 { grid-area: 1 / 2 / 2 / 3; }
        #cpu1 { grid-area: 2 / 1 / 3 / 2; }
        #cpu3 { grid-area: 2 / 3 / 3 / 4; }
        #player { grid-area: 3 / 2 / 4 / 3; }

        #center-area {
            grid-area: 2 / 2 / 3 / 3;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        #cards-zone {
            display: flex;
            gap: 30px;
            align-items: center;
            position: relative;
        }

        /* [ÏàòÏ†ïÎê®] Îç± Ïö∞Ï∏° ÏÉÅÎã® Î∞∞ÏßÄ */
        #draw-penalty-badge {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 35px;
            height: 35px;
            background-color: #d32f2f;
            color: white;
            border-radius: 50%;
            border: 3px solid white;

            /* Ï§ëÏöî: !important Ï†úÍ±∞ÌïòÍ≥† Í∏∞Î≥∏ÏùÑ noneÏúºÎ°ú ÏÑ§Ï†ï */
            display: none;
            justify-content: center;
            align-items: center;

            font-weight: 900;
            font-size: 18px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 100;
            animation: popBadge 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popBadge {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        #current-suit-indicator {
            font-size: 18px;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 5px 15px;
            border-radius: 20px;
            color: #fff;
            min-height: 27px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .suit-icon { font-size: 24px; }
        .red-suit { color: #ff5252; }
        .black-suit { color: #fff; }
        .any-suit { color: #ffeb3b; text-shadow: 0 0 5px orange; }

        .player-name {
            background: rgba(0,0,0,0.5);
            padding: 2px 10px;
            border-radius: 10px;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .card {
            width: 60px; height: 90px;
            background-color: white;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            font-weight: bold;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        }
        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }
        .card.joker-black { color: black; border: 2px solid #555; }
        .card.joker-color { color: red; border: 2px solid #ff9800; }

        .diagonal-text {
            transform: rotate(-45deg);
            font-size: 15px;
            font-weight: 900;
            letter-spacing: 0px;
        }

        .card-back {
            background-color: #1a237e;
            background-image: repeating-linear-gradient(45deg, #1a237e 0, #1a237e 5px, #283593 5px, #283593 10px);
            border: 2px solid #fff;
            color: transparent;
        }

        #deck {
            position: relative;
            overflow: visible;
        }
        #deck:active { transform: scale(0.95); }

        .cpu-hand-visual {
            display: flex; justify-content: center; align-items: center; height: 100px;
        }
        .cpu-card {
            width: 40px; height: 60px;
            border-radius: 4px;
            box-shadow: -1px 0 3px rgba(0,0,0,0.3);
            margin-left: -25px;
            transition: all 0.3s ease;
        }
        .cpu-card:first-child { margin-left: 0; }

        #cpu1 .cpu-hand-visual, #cpu3 .cpu-hand-visual {
            flex-direction: column; width: 100px; height: auto;
        }
        #cpu1 .cpu-card, #cpu3 .cpu-card {
            margin-left: 0; margin-top: -45px; transform: rotate(90deg);
        }
        #cpu1 .cpu-card:first-child, #cpu3 .cpu-card:first-child { margin-top: 0; }

        #player-hand { display: flex; gap: -5px; margin-top: 5px; }
        #player-hand .card { margin: 0 3px; }
        #player-hand .card:hover { transform: translateY(-15px) scale(1.1); z-index: 10; }

        #one-card-btn {
            position: absolute;
            width: 100px; height: 100px;
            background: radial-gradient(circle, #ffeb3b 0%, #fbc02d 100%);
            color: #d32f2f; font-size: 20px; font-weight: 900;
            border: 5px solid #d32f2f; border-radius: 50%;
            cursor: pointer; z-index: 9999; display: none;
            box-shadow: 0 0 30px #ffeb3b;
            animation: pulse 0.5s infinite;
            text-align: center; line-height: 90px;
        }
        #one-card-btn:active { transform: scale(0.9); }
        @keyframes pulse { 0% {transform:scale(1);} 50% {transform:scale(1.1);} 100% {transform:scale(1);} }

        #game-log {
            position: absolute; bottom: 10px; left: 10px;
            width: 220px; height: 150px;
            background: rgba(0,0,0,0.6); color: #ddd;
            overflow-y: auto; font-size: 11px; padding: 8px;
            border-radius: 5px; pointer-events: none;
            z-index: 50;
        }
        #game-log::-webkit-scrollbar { display: none; }

        #restart-btn {
            position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background-color: #0288d1;
            color: white; border: none; border-radius: 5px;
            font-size: 16px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: none; z-index: 10001;
        }
        #restart-btn:hover { background-color: #03a9f4; }

        #suit-modal {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none; justify-content: center; align-items: center;
            z-index: 20000; flex-direction: column;
        }
        .suit-options { display: flex; gap: 20px; margin-top: 20px; }
        .suit-btn {
            width: 80px; height: 80px;
            font-size: 40px; background: white;
            border: none; border-radius: 10px; cursor: pointer;
        }
        .suit-btn:hover { transform: scale(1.1); background: #eee; }
    </style>
</head>
<body>

<canvas id="confetti-canvas"></canvas>
<button id="restart-btn" onclick="location.reload()">üîÑ Îã§ÏãúÌïòÍ∏∞</button>

<div id="suit-modal">
    <h2 style="color:white;">Î≥ÄÍ≤ΩÌï† Î¨¥Îä¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!</h2>
    <div class="suit-options">
        <button class="suit-btn" onclick="resolveSuitSelection('‚ô†')" style="color:black">‚ô†</button>
        <button class="suit-btn" onclick="resolveSuitSelection('‚ô¶')" style="color:red">‚ô¶</button>
        <button class="suit-btn" onclick="resolveSuitSelection('‚ô•')" style="color:red">‚ô•</button>
        <button class="suit-btn" onclick="resolveSuitSelection('‚ô£')" style="color:black">‚ô£</button>
    </div>
</div>

<div id="game-board">
    <div id="cpu2" class="player-area">
        <div class="player-name">CPU 2</div>
        <div class="cpu-hand-visual"></div>
    </div>
    <div id="cpu1" class="player-area">
        <div class="player-name">CPU 1</div>
        <div class="cpu-hand-visual"></div>
    </div>
    <div id="center-area">
        <div id="current-suit-indicator"></div>
        <div id="cards-zone">
            <div id="deck" class="card card-back" onclick="playerDraw()">
                Deck
                <div id="draw-penalty-badge">0</div>
            </div>
            <div id="discard-pile" class="card"></div>
        </div>
    </div>
    <div id="cpu3" class="player-area">
        <div class="player-name">CPU 3</div>
        <div class="cpu-hand-visual"></div>
    </div>
    <div id="player" class="player-area">
        <div class="player-name">YOU</div>
        <div id="player-hand"></div>
    </div>
</div>

<div id="one-card-btn">ÏõêÏπ¥Îìú!</div>
<div id="game-log"></div>

<script>
    function setScreenHeight() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        document.body.style.height = (window.innerHeight) + "px";
    }
    window.addEventListener('resize', setScreenHeight);
    setScreenHeight();

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'play') {
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'attack') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(150, now + 0.3);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'draw') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(400, now + 0.15);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.linearRampToValueAtTime(0.01, now + 0.15);
            osc.start(now); osc.stop(now + 0.15);
        } else if (type === 'alert') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.setValueAtTime(800, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'special') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

    function playFanfare() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const notes = [523.25, 659.25, 783.99, 1046.50];
        let time = audioCtx.currentTime;
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            osc.type = 'triangle'; osc.frequency.value = freq;
            const duration = (i === notes.length - 1) ? 0.8 : 0.2;
            gainNode.gain.setValueAtTime(0.3, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + duration);
            osc.start(time); osc.stop(time + duration);
            time += 0.15;
        });
    }

    const canvas = document.getElementById('confetti-canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationId = null;
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    function createConfetti() {
        for (let i = 0; i < 150; i++) {
            particles.push({
                x: window.innerWidth / 2, y: window.innerHeight / 2,
                vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15 - 5,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                size: Math.random() * 8 + 4, gravity: 0.2, drag: 0.96
            });
        }
        animateConfetti();
    }
    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.vx *= p.drag; p.vy *= p.drag;
            ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
            if (p.y > canvas.height) particles.splice(i, 1);
        });
        if (particles.length > 0) animationId = requestAnimationFrame(animateConfetti);
        else cancelAnimationFrame(animationId);
    }

    /* ==============================
       Í≤åÏûÑ Î°úÏßÅ
       ============================== */
    const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    let deck = [];
    let discardPile = [];
    let players = [
        { id: 0, name: "YOU", isCpu: false, hand: [] },
        { id: 1, name: "CPU 1", isCpu: true, hand: [] },
        { id: 2, name: "CPU 2", isCpu: true, hand: [] },
        { id: 3, name: "CPU 3", isCpu: true, hand: [] }
    ];

    let currentPlayerIndex = 0;
    let turnDirection = 1;
    let isGameRunning = true;
    let oneCardTimer = null;
    let isProcessingTurn = false;
    let currentEffectiveSuit = null;
    let drawStack = 0;

    const discardEl = document.getElementById('discard-pile');
    const playerHandEl = document.getElementById('player-hand');
    const oneCardBtn = document.getElementById('one-card-btn');
    const logEl = document.getElementById('game-log');
    const suitIndicator = document.getElementById('current-suit-indicator');
    const suitModal = document.getElementById('suit-modal');
    const restartBtn = document.getElementById('restart-btn');
    const badgeEl = document.getElementById('draw-penalty-badge');
    const cpuVisuals = [null, document.querySelector('#cpu1 .cpu-hand-visual'), document.querySelector('#cpu2 .cpu-hand-visual'), document.querySelector('#cpu3 .cpu-hand-visual')];

    function initGame() {
        createDeck();
        shuffleDeck();
        dealCards();
        updateUI();
        log("Í≤åÏûÑ ÏãúÏûë! ÌñâÏö¥ÏùÑ ÎπïÎãàÎã§.");
        highlightCurrentPlayer();
    }

    function createDeck() {
        deck = [];
        for (let suit of suits) {
            for (let rank of ranks) {
                deck.push({ suit, rank, isJoker: false });
            }
        }
        deck.push({ suit: 'Joker', rank: 'Black', isJoker: true });
        deck.push({ suit: 'Joker', rank: 'Color', isJoker: true });
    }

    function shuffleDeck() {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }

    function dealCards() {
        for (let i = 0; i < 5; i++) {
            players.forEach(p => { if(deck.length > 0) p.hand.push(deck.pop()); });
        }
        let firstCard = deck.pop();
        discardPile.push(firstCard);

        if (firstCard.isJoker) {
            currentEffectiveSuit = 'ANY';
            log("Ï≤´ Ïπ¥ÎìúÍ∞Ä Ï°∞Ïª§! ÏïÑÎ¨¥Í±∞ÎÇò ÎÇº Ïàò ÏûàÏäµÎãàÎã§.");
        } else {
            currentEffectiveSuit = firstCard.suit;
        }
    }

    function drawCardFromDeck(player) {
        if (deck.length === 0) reshuffleDiscardPile();

        let count = (drawStack > 0) ? drawStack : 1;

        for(let i=0; i<count; i++) {
            if (deck.length > 0) {
                player.hand.push(deck.pop());
                if(deck.length === 0) reshuffleDiscardPile();
            }
        }

        playSound('draw');
        if(drawStack > 0) {
            log(`${player.name}, Í≥µÍ≤©Î∞õÏïÑ ${drawStack}Ïû• Í∞ÄÏ†∏Í∞ëÎãàÎã§!`);
            drawStack = 0;
        }
        updateUI();
    }

    function reshuffleDiscardPile() {
        if (discardPile.length <= 1) return;
        const topCard = discardPile.pop();
        const newDeck = discardPile;
        discardPile = [topCard];
        deck = newDeck;
        shuffleDeck();
        log("Îç± Î¶¨ÌïÑÎê®");
    }

    function isAttackCard(card) {
        return card.isJoker || card.rank === '2' || card.rank === 'A';
    }

    function getAttackValue(card) {
        if (card.isJoker && card.rank === 'Color') return 7;
        if (card.isJoker && card.rank === 'Black') return 5;
        if (card.rank === 'A') return 3;
        if (card.rank === '2') return 2;
        return 0;
    }

    function isValidMove(card, topCard) {
        if (drawStack > 0) {
            if (card.isJoker) return true;
            if (isAttackCard(card)) {
                return (card.rank === topCard.rank || card.suit === currentEffectiveSuit || currentEffectiveSuit === 'ANY');
            }
            return false;
        }

        if (card.isJoker) return true;
        if (topCard.isJoker || currentEffectiveSuit === 'ANY') return true;
        return card.rank === topCard.rank || card.suit === currentEffectiveSuit;
    }

    function checkOneCardEvent(playerIndex, callback) {
        const player = players[playerIndex];
        if (player.hand.length === 1) {
            spawnOneCardButton(playerIndex, callback);
        } else {
            callback();
        }
    }

    function spawnOneCardButton(targetPlayerIndex, callback) {
        playSound('alert');
        const size = 100;
        const maxX = window.innerWidth - size - 20;
        const maxY = window.innerHeight - size - 20;

        oneCardBtn.style.left = Math.max(10, Math.random() * maxX) + 'px';
        oneCardBtn.style.top = Math.max(10, Math.random() * maxY) + 'px';
        oneCardBtn.style.display = 'block';

        let clicked = false;

        oneCardBtn.onclick = () => {
            clicked = true;
            oneCardBtn.style.display = 'none';
            clearTimeout(oneCardTimer);

            if (targetPlayerIndex === 0) {
                log("ÎÇò: Î∞©Ïñ¥ ÏÑ±Í≥µ!");
            } else {
                log(`${players[targetPlayerIndex].name} Í≤¨Ï†ú ÏÑ±Í≥µ! (+1Ïû•)`);
                const tempStack = drawStack;
                drawStack = 0;
                drawCardFromDeck(players[targetPlayerIndex]);
                drawStack = tempStack;
                updateUI();
            }
            callback();
        };

        oneCardTimer = setTimeout(() => {
            oneCardBtn.onclick = null;
            if (!clicked) {
                oneCardBtn.style.display = 'none';
                if (targetPlayerIndex === 0) {
                    log("Î∞©Ïñ¥ Ïã§Ìå®... (+1Ïû•)");
                    const tempStack = drawStack;
                    drawStack = 0;
                    drawCardFromDeck(players[0]);
                    drawStack = tempStack;
                } else {
                    log(`${players[targetPlayerIndex].name}: "ÏõêÏπ¥Îìú!"`);
                }
                updateUI();
                callback();
            }
        }, 1000);
    }

    function processCardEffect(card, playerIndex) {
        const player = players[playerIndex];

        if (isAttackCard(card)) {
            const damage = getAttackValue(card);
            drawStack += damage;
            log(`Í≥µÍ≤© ÎàÑÏ†Å! +${damage} (Ï¥ù ${drawStack}Ïû•)`);
            playSound('attack');
        }

        if (card.rank === 'K') {
            log(`${player.name}: King! Ìïú Î≤à Îçî!`);
            playSound('special');
            return "REPEAT";
        }

        if (card.rank === 'Q') {
            log(`${player.name}: Queen! ÏàúÏÑú Î∞òÏ†Ñ!`);
            playSound('special');
            turnDirection *= -1;
        }

        if (card.rank === 'J') {
            log(`${player.name}: Jump! Îã§Ïùå ÏÇ¨Îûå Í±¥ÎÑàÎõ∞Í∏∞`);
            playSound('special');
            currentPlayerIndex = (currentPlayerIndex + turnDirection + 4) % 4;
        }

        if (card.rank === '7') {
            playSound('special');
            if (player.isCpu) {
                const counts = {'‚ô†':0, '‚ô•':0, '‚ô¶':0, '‚ô£':0};
                player.hand.forEach(c => { if(!c.isJoker) counts[c.suit]++; });
                const bestSuit = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                currentEffectiveSuit = bestSuit;
                log(`${player.name}Í∞Ä Î¨¥Îä¨Î•º ${bestSuit}(Ïúº)Î°ú Î≥ÄÍ≤Ω!`);
                return "NEXT";
            } else {
                openSuitModal();
                return "WAIT_UI";
            }
        }
        return "NEXT";
    }

    function resolveSuitSelection(selectedSuit) {
        suitModal.style.display = 'none';
        currentEffectiveSuit = selectedSuit;
        log(`Î¨¥Îä¨Î•º ${selectedSuit}(Ïúº)Î°ú Î≥ÄÍ≤ΩÌñàÏäµÎãàÎã§.`);
        updateUI();
        nextTurn();
    }

    function openSuitModal() {
        suitModal.style.display = 'flex';
    }

    function nextTurn() {
        if (!isGameRunning) return;

        if (checkWinCondition(currentPlayerIndex)) return;

        currentPlayerIndex = (currentPlayerIndex + turnDirection + 4) % 4;

        updateUI();
        highlightCurrentPlayer();

        if (players[currentPlayerIndex].isCpu) {
            isProcessingTurn = true;
            setTimeout(cpuPlay, 1000);
        } else {
            isProcessingTurn = false;
            if (drawStack > 0) {
                log(`ÎãπÏã†Ïùò Ï∞®Î°Ä! Î∞©Ïñ¥ÌïòÍ±∞ÎÇò ${drawStack}Ïû•ÏùÑ ÎìúÎ°úÏö∞ÌïòÏÑ∏Ïöî.`);
            } else {
                log("ÎãπÏã†Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§.");
            }
        }
    }

    function checkWinCondition(playerIndex) {
        if (players[playerIndex].hand.length === 0) {
            isGameRunning = false;
            const pName = players[playerIndex].name;
            restartBtn.style.display = 'block';

            if (playerIndex === 0) {
                playFanfare();
                createConfetti();
                log(`üéâ Ï∂ïÌïòÌï©ÎãàÎã§! ${pName} ÏäπÎ¶¨!`);
            } else {
                log(`${pName} ÏäπÎ¶¨... Îã§Ïùå Í∏∞ÌöåÏóê!`);
            }
            return true;
        }
        return false;
    }

    function playerPlayCard(cardIndex) {
        if (currentPlayerIndex !== 0 || isProcessingTurn) return;

        const card = players[0].hand[cardIndex];
        const topCard = discardPile[discardPile.length - 1];

        if (isValidMove(card, topCard)) {
            isProcessingTurn = true;

            players[0].hand.splice(cardIndex, 1);
            discardPile.push(card);

            if (card.isJoker) {
                currentEffectiveSuit = 'ANY';
            } else if (card.rank !== '7') {
                currentEffectiveSuit = card.suit;
            }

            if(!isAttackCard(card) && card.rank !== 'K' && card.rank !== 'Q' && card.rank !== 'J' && card.rank !== '7') {
                playSound('play');
            }

            updateUI();

            if (players[0].hand.length === 0) {
                checkWinCondition(0);
                return;
            }

            checkOneCardEvent(0, () => {
                const effectResult = processCardEffect(card, 0);

                if (effectResult === "WAIT_UI") {
                } else if (effectResult === "REPEAT") {
                    isProcessingTurn = false;
                    log("Ìïú Î≤à Îçî ÎÇ¥ÏÑ∏Ïöî!");
                    updateUI();
                } else {
                    nextTurn();
                }
            });

        } else {
            log("ÎÇº Ïàò ÏóÜÎäî Ïπ¥ÎìúÏûÖÎãàÎã§.");
        }
    }

    function playerDraw() {
        if (currentPlayerIndex !== 0 || isProcessingTurn) return;
        drawCardFromDeck(players[0]);
        updateUI();
        nextTurn();
    }

    function cpuPlay() {
        if (!isGameRunning) return;

        const cpu = players[currentPlayerIndex];
        const topCard = discardPile[discardPile.length - 1];

        let validIndex = -1;

        validIndex = cpu.hand.findIndex(c => isValidMove(c, topCard));

        if (validIndex !== -1) {
            const card = cpu.hand.splice(validIndex, 1)[0];
            discardPile.push(card);

            if (card.isJoker) {
                currentEffectiveSuit = 'ANY';
            } else if (card.rank !== '7') {
                currentEffectiveSuit = card.suit;
            }

            if(!isAttackCard(card) && card.rank !== 'K' && card.rank !== 'Q' && card.rank !== 'J' && card.rank !== '7') {
                playSound('play');
            }

            updateUI();

            let cardName = card.isJoker ? `JOKER` : `${card.suit}${card.rank}`;
            log(`${cpu.name} > ${cardName}`);

            if (cpu.hand.length === 0) {
                checkWinCondition(currentPlayerIndex);
                return;
            }

            checkOneCardEvent(currentPlayerIndex, () => {
                const effectResult = processCardEffect(card, currentPlayerIndex);

                if (effectResult === "REPEAT") {
                    setTimeout(cpuPlay, 1000);
                } else {
                    nextTurn();
                }
            });

        } else {
            drawCardFromDeck(cpu);
            updateUI();
            nextTurn();
        }
    }

    function updateUI() {
        const top = discardPile[discardPile.length - 1];
        let displayText = top.isJoker ? (top.rank === 'Black' ? 'ü§°' : 'üëπ') : `${top.suit}${top.rank}`;

        if (top.isJoker) {
            displayText = `<span class="diagonal-text">JOKER</span>`;
        }

        let cssClass = `card ${['‚ô•','‚ô¶'].includes(top.suit) || top.rank === 'Color' ? 'red' : 'black'}`;
        if (top.isJoker) {
            cssClass = top.rank === 'Color' ? 'card joker-color' : 'card joker-black';
        }

        discardEl.className = cssClass;
        discardEl.innerHTML = displayText;

        // [ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ] Î∞∞ÏßÄ Î≥¥Ïó¨Ï£ºÍ∏∞ Î°úÏßÅ
        if (drawStack > 0) {
            badgeEl.style.display = 'flex'; // JSÏóêÏÑú flex Ï†ÅÏö©
            badgeEl.textContent = drawStack;
        } else {
            badgeEl.style.display = 'none'; // JSÏóêÏÑú Ïà®ÍπÄ
        }

        if (currentEffectiveSuit === 'ANY') {
            suitIndicator.innerHTML = `ÌòÑÏû¨: <span class="suit-icon any-suit">ÏûêÏú† (ÏïÑÎ¨¥Í±∞ÎÇò)</span>`;
        } else {
            let suitColor = ['‚ô•','‚ô¶'].includes(currentEffectiveSuit) ? 'red-suit' : 'black-suit';
            suitIndicator.innerHTML = `ÌòÑÏû¨ Î¨¥Îä¨: <span class="suit-icon ${suitColor}">${currentEffectiveSuit}</span>`;
        }

        playerHandEl.innerHTML = '';
        players[0].hand.forEach((card, index) => {
            const d = document.createElement('div');
            let cClass = `card ${['‚ô•','‚ô¶'].includes(card.suit) ? 'red' : 'black'}`;
            let cText = `${card.suit}${card.rank}`;

            if (card.isJoker) {
                cClass = card.rank === 'Color' ? 'card joker-color' : 'card joker-black';
                cText = `<span class="diagonal-text">JOKER</span>`;
            }

            d.className = cClass;
            d.innerHTML = cText;
            d.onclick = () => playerPlayCard(index);
            playerHandEl.appendChild(d);
        });

        for(let i=1; i<=3; i++) {
            const visualContainer = cpuVisuals[i];
            visualContainer.innerHTML = '';
            const count = players[i].hand.length;
            for(let k=0; k<count; k++) {
                const cardBack = document.createElement('div');
                cardBack.className = 'card card-back cpu-card';
                visualContainer.appendChild(cardBack);
            }
        }
    }

    function highlightCurrentPlayer() {
        document.querySelectorAll('.player-area').forEach(el => el.classList.remove('active-turn'));
        const ids = ['player', 'cpu1', 'cpu2', 'cpu3'];
        document.getElementById(ids[currentPlayerIndex]).classList.add('active-turn');
    }

    function log(msg) {
        const p = document.createElement('div');
        p.textContent = msg;
        logEl.appendChild(p);
        logEl.scrollTop = logEl.scrollHeight;
    }

    window.onload = initGame;
</script>
</body>
</html>